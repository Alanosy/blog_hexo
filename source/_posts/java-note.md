---
title: Java-韩顺平笔记
date: 2023-06-20 14:24
tags: [笔记]
---

## 基础知识

1. JDK：Java开发工具包
2. JDK = JRE+java的开发工具[java,javac,javadoc,javap等]
3. JRE：java运行环境 JRE = JVM+java核心类库[类]
4. JDK = JRE + 开发工具集
5. jRE = JVM + javaSE标准类库
6. 如果只想运行开发好的.class文件，只需要JRE

## 流程分析

.java 文件---javac--->.class---java--->结果

源文件--编译-->字节码文件--运行-->结果

## 开发注意事项和细节说明

1. java 源文件以.java 为扩展名。源文件的基本组成部分是类（class）
2. java 应用程序执行入口时 main()方法，
3. java 语言严格区分大小写
4. 每条语句以;结尾
5. 一个源文件最多**只能有一个 public 类**，其他类不限数量
6. 打括号都是成对出现，缺一不可[习惯先写{}再写代码]
7. 如果源文件包含一个 public 类，则**文件名必须按该类名命名**
8. 一个源文件最多只能有一个 public 类，其他类不限数量，也可以将 main 方法写在其他的非 public 类中，然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法

## 转义字符

| 转义字符 | 含义                     |
| -------- | ------------------------ |
| \t       | 一个制表符，实现对齐功能 |
| \n       | 换行符                   |
| \\\      | 一个\                    |
| \\"      | 一个"                    |
| \\'      | 一个'                    |
| \r       | 一个回车                 |

``` java
package javabase;

/**
 * @author alan
 * @version 1.0
 */
public class TransferredMeaning {
	public static void main(String[] args) {
		System.out.println("北京\t天津\t上海");
		System.out.println("jack\nsmith\nmary");
		System.out.println("北京\\天津\\上海");
		System.out.println("北京\r天津\r上海");
		System.out.println("北京\"天津\'上海");

	}
}
```



## 易犯的错误

1. 找不到文件
2. 主类名于文件名不一致
3. 缺少分号

## 注释

* 将自己的思想通过注释先整理出来，再用代码去体现

1. 单行注释
2. 多行注释
3. 文档注释

* 单行注释
  * 格式： // 注释文本

* 多行注释
  * 格式 ：/* 注释文本 */

* 文档注释
  * 格式：/** 注释文本  */

**使用细节**：

1. 被注释的文字，不会被 JVM 解释执行
2. 多行注释里面不允许有多行注释嵌套

## 文档注释

注释内容可以被 JDK 提供的工具 javadoc 所解析，生产一套以网页形式呈现的呈现的说明文档，一般写在类

```java
package javabase;

/**
 * @author alan
 * @version 1.0
 */
public class TransferredMeaning {
	public static void main(String[] args) {
		System.out.println("北京\t天津\t上海");
		System.out.println("jack\nsmith\nmary");
		System.out.println("北京\\天津\\上海");
		System.out.println("北京\r天津\r上海");
		System.out.println("北京\"天津\'上海");

	}
}
```

```base
javadoc -d . -author -version TransferredMeaning
```

-d 指定地址

-author 指定作者标签

-version 指定版本标签

## java 代码规范

1. 类、方法的注释要以 javadoc 的方式来写
2. 非 javadoc 的注释往往时给代码的维护者看的，着重告诉读者如何修改，注意什么问题
3. 使用 tab 操作，实现缩进，默认整体移动，时候用 shift+tab 整体向右移动
4. 运算符和=两边习惯性各加一个空格
5. 源文件使用 utf-8 编码
6. 行宽不要超过 80 字符
7. 代码编写**次行风格**和**行尾风格**（推荐）

## 变量原理

变量是程序基本组成单位

三个基本要素（类型+名称+值）

底层名称就像指针，指向内存中的值

## 变量的概念

变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号外面可以找到房间，而通过变量名可以访问到变量值

**基本步骤**

1.声明变量

int a;

2.赋值

a=10;

## 变量使用细节

1. 变量表示内存中的一个存储区域[不同的变量，类型不同，占用的空间大小不同]
2. 该区域有自己的名称[变量名]和类型[数据类型]
3. 变量必须先声明，后使用，即有顺序
4. 该区域的数据/值可以在同一类型范围内不断改变
5. 变量在同一个作用于内不能重名
6. 变量=变量名+值+数据类型

## 加号的使用

当左右两边都是数值时，做加法运算

当左右两边为字符串，则做拼接运算

## 数据类型

每一种数据都定义了明确的数据类型，在内侧中分配了不同大小的内存空间

```yml
数据类型:
	基本数据类型:
		数值型:
			整数:
				byte[1]、short[2]、int[4]、long[8]
			浮点型:
				float[4]、double[8]
		字符型:
			char[2]
		布尔型:
			boolean[1]
	引用数据类型:
		类 class
		接口 interface
		数组 []
```

## 整数类型

| 类型  | 占用空间 | 范围         |
| ----- | -------- | ------------ |
| byte  | 1        | -128~127     |
| short | 2        | -2^15~2^15-1 |
| int   | 4        | -2^32~2^32-1 |
| long  | 8        | -2^63~2^63-1 |

## 整型细节

1. java 各整数类型有固定的范围和字段长度，不受具体 os 的影响，以保证 java 呈现的可以移植性
2. java 的**整型常量默认为 int 型**，声明 long 型出来需要在后面加**'l'或"L"**
3. java 程序中变量常声明 int 型，除非不足以表示大数，才使用 long
4. bit：计算机中最小存储单位，byte：计算机中基本存储单元，1byte = 8bit

``` java
int n1 = 1; //4个字节
int n2 = 1L;//对不对?不对
long n3 = 1L;//对
 
```



## 浮点型使用

| 类型          | 占用空间 |
| ------------- | -------- |
| 单精度 float  | 4 字节   |
| 双精度 double | 8 字节   |

**浮点数=符号位+指数位+尾数位**

尾数部分可能丢失，造成精度损失（小数都是近似值）

***小数相加都是近似值***

## 浮点型细节

1. 与整数类型类似，java 浮点类型也有固定的范围和字段长度，不受具体 os 的影响

2. java 的**浮点型常量默认为 double 型**，声明 float 型常量，须后加'f'或'F'
   1. 因为默认时 double 所以 float n1 = 1.1;会报错加个 f 就不会报错了

3. 浮点型常量有两种形式
   1. 十进制形式：如 5.12,   512.0f,   .512（必须要有小数点）。
   2.  科学计数形式：如 5.12e2[5.12*10 的 2 次方]         5.12E-2[5.12 除以 10 的 2 次方]
   3. 0.532 可以省略 0 但不能省略.

4. 通常情况下，应该使用 double 型因为它比 float 型更精确

   1. ``` java
      double num9 = 2.1234567851;//2.1234567851
      float num10 = 2.1234567851F;//2.1234567
      
      float num1 = 1.1;//错误
      float num2 = 1.1F;//对
      double num3 = 1.1;//对
      double num4 = 1.1f;//对
      double num5 = .123;//等价0.123
      System.out.println(5.12e2);//512.0
      System.out.println(5.12E-2);//0.0512
      ```

5. 浮点数使用陷阱：2.7 和 8.1/3 比较
   1. ```java
      double num11 = 2.7;//2.7
      double num12 = 8/3;//2.6999999999999997
      //错误写法
      if( num11 == num12) {
      	System.out.println("num11 == num12 相等");
      }
      //正确写法
      if(Math.abs(num11 - num12) < 0.000001 ) {
      	System.out.println("差值非常小，到我的规定精度，认为相等...");
      }
      ```

   2. 当我们运算结果时小数的进行相判断，要小心 错误写法 num11 == num12

   3. 应该是以两个数的差值的绝对值，在某个精度范围类判断 Math.abs(num11 - num12)<0.000001

单精度太长，会被舍去

## API 文档

JDK->包->类、接口、异常->构造方法、字段、成员方法

## 字符类型（char）

字符类型可以表示**单个字符**，字符类型是 char，char 是两个字节（可以存放汉字）多个字符我们用字符串 String

可以直接存放一个数字

```java
char c1 = 'a';
char c1 = '\t';
char c1 = 97;
char c1 = '韩';
```

## 字符类型细节

1. 字符常量使用**单引号('')括**起来的单个字符，**双引号会报错**
2. java 中允许使用转义字符'\n'来将其后的字符转变为特殊字符常量
3. 在 java 中，char 的本质是一个整数，在默认输出时**Uniconde 码**对应的字符，要输出数字须转型为 int
4. 可以直接给 char 赋一个整数，然后输出时，会按照对应的 unicode 字符输出
5. char 类型是**可以进行运算**的，相当于一个整数，因为它都对应有 unicode 码

```java
char c1 = 97;
System.out.println(c1); // a

char c2 = 'a'; //输出'a' 对应的数字
System.out.println((int)c2);//97

System.out.println('a' + 10);//107

chat c5 = 'b' + 1;
System.out.println((int)c5); //99->对应的字符->编码表ASCII(规定好的)=>c
SYstem.out.println(c5); // c
```

## 字符型的本质

1. 字符型存储到家睡觉中，需要将字符对于到码值（整数）找出来
   1. 存储：'a'==>码值 97==>二进制==>存储
   2. 读取：二进制==>97==>'a'=>显示
2. 字符和码值的对应关系是通过字符编码表决定的
3. 编码表
   1. ASCII（一个字节表示，一个 128 个字符）
   2. Unicode（固定大小的编码，使用两个字节来表示，字符和汉字统一都是占用两个字节）
   3. utf-8（大小可变，字母使用 1 个字节，汉字 3 个字节）
   4. gbk（可以表示汉字，而且范围广，字母 1 字节，汉字 2 字节）
   5. Gb2312（可以表示汉字，关闭 312<gbk）
   6. big5 码（繁体中文，台湾，香港）

## 常用编码（了解）

1. ASCII 码 ，缺点不能完全显示
2. Unicode 的好处一种编码，将世界上所有字符的符号都纳入其中，每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码问题，缺点，一个英文和一个汉字都占 2 字节，对于存储空间来说是浪费
3. Unicode 码兼容 ASCII
4. UTF-8 是互联网上使用最广泛的一种 Unicode 的实现方式
5. 使用大小可变的编码，字母 1 字节，汉字 3 字节

## 布尔类型

1. 布尔类型也叫 boolean，只允许取值 true 和 false，无 null
2. boolean 类型占 1 字节
3. boolean 适用于逻辑运算，一般用于程序流控制

使用细节说明：

不可以 0 或非 0 的整数代替 false

## 基本类型转换

当java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的类型，这就是自动类型转换

char -> int ->long -> float -> double

byte ->short -> int -> long -> float -> double

``` ;
int a = 'c';
double d = 80;
```

## 基本数据类型转换细节

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量**最大**的那种数据类型，然后再进行计算

2. 当我们把**精度大**的数据类型赋值给精度小的数据类型时，就会报错，**反之**就会进行**自动类型转换**
3. (Byte,short)和char之间**不会相互自动转换**
4. byte，short，char他们三者可以计算，在计算时首先转换为int类型
5. boolean**不参与转换**
6. 自动提升原则：表达式结果的类型自动提升为操作数中**最大**的类型
7. 当把具体数赋给byte 时，(1)先判断该数是否在byte 范围内，如果是就可以，如果是变量赋值则不行

``` java
int n1 = 10;//ok
float d1 = n1+ 1.1;//错误n1+1.1->double
double d1 = n1 + 1.1;//对，结果为double
float d1 = n1 + 1.1F;//对n1+1.1F->float
int n2 = 1.1;//错误double->int
byte b1 = 10;//对 -128-127 当把具体数赋给byte 时，(1)先判断该数是否在byte 范围内，如果是就可以
int n2 = 1;//n2时int
byte b2 = n2;//错误,原因，如果是变量赋值，判断类型
char c1 = b1;//错误原因byte不能自动转换成char
```

``` java
//细节4: byte，short，char 他们三者可以计算，在计算时首先转换为int 类型
byte b2 = 1;
byte b3 = 2;
short s1 = 1;
//short s2 = b2 + s1;//错, b2 + s1 => int
int s2 = b2 + s1;//对, b2 + s1 => int
//byte b4 = b2 + b3; //错误: b2 + b3 => int
//
//boolean 不参与转换
boolean pass = true;
//int num100 = pass;// boolean 不参与类型的自动转换
//自动提升原则： 表达式结果的类型自动提升为操作数中最大的类型
//看一道题
byte b4 = 1;
short s3 = 100;
int num200 = 1;
float num300 = 1.1F;
double num500 = b4 + s3 + num200 + num300; //float -> double
```



## 强制类型转换(ForceConvent)

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符（），但可能造成**精度降低或溢出**，格外要注意

``` java
int i = (int)1.9; //精度降低
System.out.println(i)//1
  
int j = 100;
byte b1 = (byte)j;  //溢出
System.out.println(b1); //-48

//强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级
//int x = (int)10*3.5+6*1.5;//编译错误： double -> int
int x = (int)(10*3.5+6*1.5);// (int)44.0 -> 44
System.out.println(x);//44
char c1 = 100; //ok
int m = 100; //ok
//char c2 = m; //错误
char c3 = (char)m; //ok
System.out.println(c3);//100 对应的字符, d 字符
```

## 强制类型转换细节

1. 当进行数据的从**大**的类型转向**小**的类型时，就需要使用到强制转换

2. 强制符号只针对**最进**的操作有效，往往会使用小括号提升优先级

   1. ``` java
      // int x = (int)10*3.5+6*1.5;
      int y = (int)(10*3.5+6*1.5);
      System.out.println(y);
      ```

      

3. char类型可以保存int的常量**值**，但不能保存int的**变量**值，需要强转

   1. ``` java
      char c1 = 100; // ok
      int m = 100; // ok
      char c2 = m; // 错误
      char c3 = (char)m; // ok
      System.out.println(c3)// 100对应的字符
      ```

4. byte、short、char类型进行**运算**时，当作**int**类型处理

## 练习题

``` java
short s = 12;//ok 12虽然时整型，但是在sort范围内，所以赋值时，先看是否在范围内
s = s - 9 ; //错误 s-9 为int ,int -> short，从大到小没有强转，所以错误

byte b = 10; //ok 在范围内
b = b + 11;// 错误 int->byte
b = (byte)(b+11);//正确，大到小+强转3333

char c = 'a'; //ok
int i = 16;//ok
float d = .3.14F;//ok
double result = c + i + d; // ok float -> double

byte b = 16 ;//ok
short s = 14; //ok
short t = s + b; //错误 byte short char参与运算会变成int 类型
```



## 基本数据类型和String类型的转换

基本类型转String类型

语法：基本类型的值 +""

String类型转基本数据类型

语法：通过基本类型的包装类调用parseXX方法即可

``` java
//基本数据类型->String
int n1 = 100;
float f1 = 1.1F;
double d1 = 4.5;
boolean b1 = true;
String s1 = n1 + "";
String s2 = f1 + "";
String s3 = d1 + "";
String s4 = b1 + "";
System.out.println(s1 + " " + s2 + " " + s3 + " " + s4);
//String->对应的基本数据类型
String s5 = "123";
//会在OOP 讲对象和方法的时候回详细
//解读使用基本数据类型对应的包装类，的相应方法，得到基本数据类型
int num1 = Integer.parseInt(s5);
double num2 = Double.parseDouble(s5);
float num3 = Float.parseFloat(s5);
long num4 = Long.parseLong(s5);
byte num5 = Byte.parseByte(s5);
boolean b = Boolean.parseBoolean("true");
short num6 = Short.parseShort(s5);
System.out.println("===================");
System.out.println(num1);//123
System.out.println(num2);//123.0
System.out.println(num3);//123.0
System.out.println(num4);//123
System.out.println(num5);//123
System.out.println(num6);//123
System.out.println(b);//true
//怎么把字符串转成字符char -> 含义是指把字符串的第一个字符得到
//解读s5.charAt(0) 得到s5 字符串的第一个字符'1'
System.out.println(s5.charAt(0));
```

## 基本数据类型和String类型的转换细节

1. 在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如我们把“123”转成一个整数，但是不能把“hello”转换成一个整数
2. 如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节会处理

## 运算符

1. 算术运算符
2. 关系运算符
3. 逻辑运算符
4. 赋值运算符
5. 三元运算符
6. 位运算
7. 运算符优先级

用以表示数据的运算，赋值，比较

**算术运算符**

| 运算符 | 运算                                               | 范例                   | 结果    |
| ------ | -------------------------------------------------- | ---------------------- | ------- |
| +      | 正号                                               | +7                     | 7       |
| -      | 负号                                               | b=11;-b                | -11     |
| +      | 加                                                 | 9+9                    | 18      |
| -      | 减                                                 | 10-8                   | 2       |
| /      | 除                                                 | 9/9                    | 1       |
| %      | 取模                                               | 11%9                   | 2       |
| ++     | 自增（前）：先运算后取值，自增（后）：先取值后运算 | a=2;b=++a;   a=2;b=a++ | a=3;b=3 |

## 算术运算符的具体使用(ArithmeticOperator)

1. +，-，*,/,%,++,--,重点讲/，%，++

   1. **在% 的本质看一个公式!!!! a % b = a - a / b * b**

   2. ```java
      //使用
      System.out.println(10 / 4); //从数学来看是2.5, java 中2
      System.out.println(10.0 / 4); //java 是2.5
      // 注释快捷键ctrl + /, 再次输入ctrl + / 取消注释
      double d = 10 / 4;//java 中10 / 4 = 2, 2=>2.0
      System.out.println(d);// 是2.0
      // % 取模,取余
      // 在% 的本质看一个公式!!!! a % b = a - a / b * b
      // -10 % 3 => -10 - (-10) / 3 * 3 = -10 + 9 = -1
      // 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1
      // -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1
      System.out.println(10 % 3); //1
      System.out.println(-10 % 3); // -1
      System.out.println(10 % -3); //1
      System.out.println(-10 % -3);//-1
      //++的使用
      //
      int i = 10;
      i++;//自增等价于i = i + 1; => i = 11
      ++i;//自增等价于i = i + 1; => i = 12
      System.out.println("i=" + i);//12
      /*
      作为表达式使用
      前++：++i 先自增后赋值
      后++：i++先赋值后自增
      */
      int j = 8;
      //int k = ++j; //等价j=j+1;k=j;
      int k = j++; // 等价k =j;j=j+1;
      System.out.println("k=" + k + "j=" + j);//8 9
      ```

2. 自增++

   1. 作为独立的语句使用

   2. 前++和后++都完全等价于i=i+1

   3. 作为表达式使用

      前++：++i 先自增后赋值

      后++：i++先赋值后自增

3. --，+，-，*是一个道理，完全可以类推



1. 对于除号"/",它的整数除和小数除湿有区别的：整数之间做除法时，只保留整数部分，而舍去小数部分
2. 党对一个数取模时，可以等价a % b = a - a / b * b,这样我们可以看到取模的一个本质运算
3. 当自增当作一个独立语言使用时，不管是++i还是i++都是一样的，等价
4. 当自增当作一个表达式使用时j=++i等价?
5. 当自增当作一个表达式使用时j=i++等价?



1. 面试题

   1. ``` java
      int i = 1;//i->1
      i = i++;//规则使用变量(1)temp = i;(2)i=i+1;(3)i=temp;
      System.out.println(i);//1
      ```

   2. ``` java
      int i = 1;//i->1
      i = ++i;//规则使用变量(1)i=i+1;(2)temp = i;(3)i=temp;
      System.out.println(i);//1
      ```

``` JAVA
1) 假如还有59 天放假，问：合xx 个星期零xx 天
2) 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。
[234.5]
  

```

``` java
//1.需求:
//假如还有59 天放假，问：合xx 个星期零xx 天
//2.思路分析
//(1) 使用int 变量days 保存天数
//(2) 一个星期是7 天星期数weeks： days / 7 零xx 天leftDays days % 7
//(3) 输出
//3.走代码
int days = 25911;
int weeks = days / 7;
int leftDays = days % 7;
System.out.println(days + "天合" + weeks + "星期零"
+ leftDays + "天");
```

``` java
//定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为
//：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度
//
//2 思路分析
//(1) 先定义一个double huaShi 变量保存华氏温度
//(2) 根据给出的公式，进行计算即可5/9*(华氏温度-100)
// 考虑数学公式和java 语言的特性
//(3) 将得到的结果保存到double sheShi
//3 走代码
double huaShi = 1234.6;
double sheShi = 5.0 / 9 * (huaShi - 100);
System.out.println("华氏温度" + huaShi
+ " 对应的摄氏温度=" + sheShi);
```



## 关系运算符

1) 关系运算符的结果都是boolean 型，也就是要么是true，要么是false

2) 关系表达式经常用在if 结构的条件中或循环结构的条件中

==,!=,<,><=,>=,instanceof检查是否是类的对象

1. 关系运算符的结果都是boolean 型，也就是要么是true，要么是false。

2) 关系运算符组成的表达式，我们称为关系表达式。a > b

3) 比较运算符"=="不能误写成"="

## 逻辑运算符

1) 短路与&& ， 短路或||，取反!

2) 逻辑与&，逻辑或|，^ 逻辑异或

 说明逻辑运算规则：

1) a&b : & 叫逻辑与：规则：当a 和b 同时为true ,则结果为true, 否则为false

2) a&&b : && 叫短路与：规则：当a 和b 同时为true ,则结果为true,否则为false

3) a|b : | 叫逻辑或，规则：当a 和b ，有一个为true ,则结果为true,否则为false

4) a||b : || 叫短路或，规则：当a 和b ，有一个为true ,则结果为true,否则为false

5) !a : 叫取反，或者非运算。当a 为true, 则结果为false, 当a 为false 是，结果为true

6) a^b: 叫逻辑异或，当a 和b 不同时，则结果为true, 否则为false

4.4.3&& 和& 基本规则

名称语法特点

短路与&& 条件1&&条件2 两个条件都为true，结果为true,否则false

逻辑与& 条件1&条件2 两个条件都为true，结果为true,否则false

``` java
//&&短路与和& 案例演示
int age = 50;
if(age > 20 && age < 90) {
  System.out.println("ok100");
}
//&逻辑与使用
if(age > 20 & age < 90) {
System.out.println("ok200");
}
//区别
int a = 4;
int b = 9;
//对于&&短路与而言，如果第一个条件为false ,后面的条件不再判断
//对于&逻辑与而言，如果第一个条件为false ,后面的条件仍然会判断
if(a < 1 & ++b < 50) {
System.out.println("ok300");
}
System.out.println("a=" + a + " b=" + b);// 4 10
```

1) &&短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高

2) & 逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低

3) 开发中， 我们使用的基本是使用短路与&&, 效率高

## 或运算

4.4.6|| 和| 基本规则

名称语法特点

短路或|| 条件1||条件2 两个条件中只要有一个成立，结果为true,否则为false

|逻辑或条件1|条件2 只要有一个条件成立，结果为true,否则为false

``` java
//||短路或和|逻辑或案例演示
//|| 规则: 两个条件中只要有一个成立，结果为true,否则为false
//| 规则: 两个条件中只要有一个成立，结果为true,否则为false
int age = 50;
if(age > 20 || age < 30) {
System.out.println("ok100");
}
//&逻辑与使用
if(age > 20 | age < 30) {
  System.out.println("ok200");
}
//看看区别
//(1)||短路或：如果第一个条件为true，
//则第二个条件不会判断，最终结果为true，效率高
//(2)| 逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低
int a = 4;
int b = 9;
if( a > 1 || ++b > 4) { // 可以换成| 测试
System.out.println("ok300");
}
System.out.println("a=" + a + " b=" + b); //4 10
```

4.4.8|| 和| 使用区别

1) ||短路或：如果第一个条件为true，则第二个条件不会判断，最终结果为true，效率高

2) | 逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低

3) 开发中，我们基本使用||

4.4.9! 取反基本规则

名称语法特点

! 非（取反） !条件如果条件本身成立，结果为false，否则为true

``` java
//! 操作是取反T->F , F -> T
System.out.println(60 > 20); //T
System.out.println(!(60 > 20)); //F
//a^b: 叫逻辑异或，当a 和b 不同时，则结果为true, 否则为false
boolean b = (10 > 1) ^ ( 3 > 5);
System.out.println("b=" + b);//T
```

a^b: 叫逻辑异或，当a 和b 不同时，则结果为true, 否则为false

^逻辑异或，System.out.println( (4 < 1) ^ (6 > 3) ); // ?

## 练习

``` java
int x = 5;
int y = 5;
if (x++==6 & ++y == 6){//false and true
  x = 11;
}
System.out.println("x="+x+,"y="+y)// 6,6
```

``` java
int x = 5;
int y = 5;
if (x++==6 && ++y == 6){//false and true
  x = 11;
}
System.out.println("x="+x+,"y="+y)// 6,5
```

``` java
int x = 5;
int y = 5;
if (x++==5 || ++y == 5){//true and false
  x = 11;
}
System.out.println("x="+x+,"y="+y)// 11,6
```

``` java
int x = 5;
int y = 5;
if (x++==5 | ++y == 5){//true and false
  x = 11;
}
System.out.println("x="+x+,"y="+y)// 11,5
```

## 赋值运算符

分类

* 基本赋值运算符 int a = 10;
* 复合运算符
  * +=，-=，*=，/=，%=，重点讲+=

## 赋值运算符演示

1. 运算顺序从右向左
2. 赋值运算符的左边，只能是变量，右边可以是变量，表达式，常量值
3. 复合赋值运算符等价于 a+=3.   a=a+3
4. 复合运算符会进行类型转换 byte b = 2;b += 3    b=(byte)(b+2) 
5. b++ b=(byte)(b+1)

## 三元运算符

语法

``` java
条件表达式?表达式1:表达式2;
```

运算规则：

1.如果条件表达式为true，运算后的结果是表达式1；

2.如果条件表达式为false，运算后的结果是表达式2；

## 三元运算符细节

1. 表达式1和表达式2要诶可以赋值给接收变量的类型（或可以自动转换）
2. 三元运算符可以转换成if-else语句

``` java
int a = 3;
int b = 8;
int c = a >b ? (int)1.1 : (int)3.4;
double d = a > b ? a:b + 3;
```

## 运算符的优先级

   ## 标识符的命名规则和规范

1. java对各种变量、方法和类等命名时使用字符序列称为标识符
2. 凡是自己可以起名字的地方都叫标识符

标识符命名规则

1. 由26个英文字母大小写，0～9，_或$组成
2. 数字不可以开头
3. 不可以使用关键字和保留字，但能包含关键字和保留字
4. java中严格区分大小写，长度无限制
5. 标识符不能包含空格

## 标识符命名的规范

1. 包名：多单词组成时所有字母都小写
2. 类名、接口名：多个单子组成时，所有单词的首字母大写（大驼峰）
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写
4. 常量名：所有字母都大写，多单词时每个单词用下划线连接
5. 后面我们学习到类，包，接口，等时，我们的命名规范要这样遵守

## 关键字

被java语言赋予特殊含义，专门用途哦的字符串

特点：关键字中所有字母都为小写

保留字：现在java版本尚未使用，但以后版本可能会作为关键字使用，自己命名时应避免使用这些保留字

## 键盘输入语句

扫描器：Scanner

步骤

1. 导入该类所在包 java.util.*
2. 创建类对象（声明变量）
3. 接收用户的输入，使用相关的方法

``` java
Scanner scanner = new Scanner(System.in);
String name = scanner.next();
int age = scanner.nextInt();
double sal = scanner.nextDouble();
```

## 进制

1. 二进制以0b或0B开头
2. 十进制
3. 八进制以0开头
4. 十六进制一0x或0X开头，A-F不区分大小写

## 进制转换

二转八、十六

三位一组，4位一组



## 原码、反码、补码

对于有符号的而言

1. 二进制的最高位是符号位：0表示正数，1表示负数（0->0,1->-)
2. 正数的原码，反码，补码都一样（三合一）
3. 负数的反码=它原码符号位不变，其他位取反(0->1,1->0)
4. 负数的补码=它的反码+1，负数的反码=负数的补码-1
5. 0的反码，补码都是0
6. java没有无符号数，换言之，java中的数都是由符号的
7. 在计算机运算的时候，都是以**补码**的方式来运算的
8. 党我们看运算结果的时候，要看它的原码

## 位运算

java中有8个位运算符（&,|,^,~,>>,<<,>>>)

分别是按位与&，按位或|，按位异或^按位取反~，他们的运算规则是：

按位与&:两位全为1，结果为1，否则为0

按位或｜：两位有一个为1，结果为1，否则为0

按位异或^：两个一个为0一个为1，结果为1，否则为0

按位取反～：0>1,1>0

```java
System.out.println(~-2); //1
//-2原码	10000000 00000000 00000000 00000010
//-2的反码 11111111 11111111 11111111 11111101
//-2的补码 00000000 00000000 00000000 00000001
//运算后的原码 00000000 00000000 00000000 00000001
System.out.println(~2); // -3
//2原码	00000000 00000000 00000000 00000010
//~2的操作 11111111 11111111 11111111 11111101
//运算后的反码 11111111 11111111 11111111 11111100
//运算后的原码 10000000 00000000 00000000 00000011
```

3个位运算符>>、<<和>>>

1. 算术右移>>：低位溢出，符号位不变，并用符号位补溢出的高位
2. 算术左移<<：符号位不变，低位补0
3. \>\>\>逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补0
4. 特变说明：没有<<<

向右边移动一位相当于除以2

向左移动一位相当于乘以2

``` java
-10.5%3=-1.5

//a%b当a是小数时，公式=a-(int)a/b*b
//有小数参与运算得到的是近似值
  
int i = 66;
System.out.println(++i+i)//执行i=i+1=>i+67=>134
```

``` java
int num1 = (int)"18";//错误 Interger.parseInt("18")
int num2 = 18.0; //错误double->int
double num3 = 3d; // ok.d代表double
double num4 = 8;//ok int->double
int i = 48; char ch = i+1;//错误int ->char
byte b = 19;short s = b+2;//错误int -> short

```

## 控制结构

## 顺序控制

查询从上到下逐行执行，中间没有任何判断和跳转

## 分支控制（if-else)

**单分支**

基本语法

``` java
if (条件表达式){
	执行代码块;
}
```

当条件表达式为true时，就会执行{}中的代码，如果为false就不执行

如果{}中只有一条语句，则可以不用{}但建议写上

**双分支**

基本语法

``` java
if (条件表达式){
  执行代码1;
}else{
  执行代码2;
}
```

**多分支**

基本语法

``` java
if (条件表达式){
  代码块1;
} else if (条件表达式2) {
  代码块2；
} else {
  代码块3;
}
```

只能有一个执行入口

特别说明：多分支可以没有else,如果所有条件都不成立，则一个执行入口都没有

注意判断范围

## 嵌套分支

规范：不要超过3层

## Switch分支结构

1. switch关键字，表示分支
2. 表达式对应一个值
3. case常量1:当表达式的值等于常量1，就执行语句块1
4. break：表示退出swtich
5. 如果和case常量1匹配，就执行语句块1，如果没有匹配就继续匹配2
6. 如果一个都没匹配上就执行default

没break会穿透

## 细节讨论

* 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以互相比较多类型

* switch（表达式）中表达式的返回值必须是（byte,short,int,char,enum,String）

  * ```java
    double c = 1.1;
    switch(c){//错误
    	case 1.1:
    		System.out.println("ok");
    		break;
    }
    ```

* case子句中的值必须是常量，而不能是变量
* default子句是可选的，当没有匹配的case时，执行default
* break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾

## switch与if-else的区别

* 如果判断的具体数值不多而且符合byte、short、int、char、enum、String这6种类型。虽然两个语句都可以使用，建议使用switch语句
* 其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广 

## for循环控制

循环操作只有一条语句可以省略{}但不建议省略

## 细节

1. 循环条件时返回一个布尔值的表达式

2. for（;循环判断条件;）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略

3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用**逗号**隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

4. ```
   int count = 3;
   for (int i = 0,j = 0; i < count;i++, j+=2){
   	System.out.println(i+""+j);
   }
   ```

## while循环控制

```
while(循环条件){
	循环体;
	循环变量迭代;
}
```

while也有四要素

细节

循环条件返回的事一个布尔值

执行时先判断后执行

## do while



## 134 多重循环

最好不要超过3次

设置外层循环次数为m次，内层为n次，则内层循环提实际上需要执行m*n次

## break

当某个条件满足时，终止小循环

细节

break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的时那一层的语句块

标签的基本使用

``` java
lable1:
for(int j = 0; j < 4;j++){
lable2:
  for(int i = 0;i<10;i++){
    if(i==2){break lable1;}
  }
}
```

1. break语句可以指定退出那一层
2. lable1时标签，由程序员决定
3. break后指定到那个lable就退出到那里
4. 在实际的开发中，尽量不要使用标签
5. 如果没有指定break，默认退出最近的循环体

## 144 continue

用于结束本次循环，继续执行下一次循环

continue语句出现在多层嵌套语句体中时，可以通过标签指明要逃过的时那一层循环，这个和签名的标签的使用的规则一样

跳转控制语句 return

用来方法中，跳出所在方法，如果在main方阵中则是退出程序

## 158 数组

第一种用法

定义

``` java
double[] a = new double[5];
```

数组的引用

数组名[索引]



第二种用法

先声明

Double[] a;

创建数组

数组名=new double[5];



第三种用法

数据类型[] 数组名={1,2,3....}

这个用法相当于int[] a = new int[9];

a[0]=1;a[1]=2....

## 注意事项

1. 数组时多个相同类型数据的组合，实现对这个数据的统一管理
2. 数组重点元素可以时任何数据类型，包括基本类型和引用类型，但是不能混用
3. 数组创建后，如果没有赋值，有默认值int 0, short 0, byte 0,long 0,float 0.0,double 0.0,char \u0000boolean false, String null
4. 使用数组的步骤，1.声明数组并开辟空间，2给数组个元素赋值，3.使用数组
5. 数组的下表从0开始
6. 数组下表必须在指定范围内使用，否则报下表越界异常
7. 数组属引用来性，数组型数据时对象
8. 



## 数组的扩容，索减、排序、查找
