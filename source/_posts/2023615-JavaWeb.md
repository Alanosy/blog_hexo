---
Title: JavaWeb
Date: 2023/6/15 16:10
Tags: [笔记]
---



## 简单请求参数

http://localhost:8080/xxx?name=1&age=2

```java
    @RequestMapping("/simpleParam")
    public String simpleParam(HttpServletRequest request){
        String name = request.getParameter("name");
        String age = request.getParameter("age");
        return name+age;
    }
```

```java
    @RequestMapping("/simpleParam")
    public String simpleParam(String name, Integer age){

        return name+age;
    }
```

如果参数名不匹配，则使用@RequestParam建立映射

```java
    @RequestMapping("/simpleParam")
    public String simpleParam(@RequestParam(name="name",required = false)String username, Integer age){

        return username+age;
    }
```

将参数封装到实体类

```java
    @RequestMapping("/simplePojo")
    public String simplePojo(User user){

        return user.getName() +user.getAge();
    }
```

## 接收数组参数

http://localhost:8080/xxx?hobby=1&hobby=2&hobby=3

```java
    @RequestMapping("/arrayParam")
    public String arrayParam(String[] hobby){

        System.out.println(Arrays.toString(hobby));
        return "ok";
    }
```

```java
    @RequestMapping("/arrayParam2")
    public String arrayParam2(@RequestParam List<String> hobby){

        System.out.println(hobby);
        return "ok";
    }
```

## 日期参数

http://localhost:8080/xxx?updateTime-2022-12-12 10:05:45

```java
    @RequestMapping("/arrayParam3")
    public String arrayParam3(@DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")LocalDateTime updateTime){
        System.out.println(updateTime);

        return "ok";
    }
```

## Json参数

json数据键名与形参属姓名相同，定义pojo类型即可接收参数，需要使用@RequesBody标示

```json
{
    "name":"Tom",
    "age":10,
    "address":{
        "name":"shanghai"
    }

}
```

```java
    @RequestMapping("/arrayParam4")
    public String arrayParam4(@RequestBody User user){
        System.out.println(user);

        return "ok";
    }
```

## 路径参数

通过请求URL直接换地参数用{}来识别路径参数，需要使用@PathVariable来获取路径参数

http://localhost:8080/arrayParam5/1

```
    @RequestMapping("/arrayParam5/{id}")
    public String arrayParam5(@PathVariable Integer id){
        System.out.println(id);

        return "ok";
    }
```

http://localhost:8080/arrayParam5/1/2

    @RequestMapping("/arrayParam5/{id}/{name}")
    public String arrayParam5(@PathVariable Integer id,@PathVariable Integer name){
        System.out.println(id+name);
    
        return "ok";
    }

## 相应数据

都来源于注解@ResponseBody只不过@RestController中已经包含

返回字符串就直接但会

实体类对象会转json

数组依然是数组  

统一都响应结果

```
public class Result{
	//相应码，1代表成果，0代表失败
	private Integetr code;
	//提示信息
	private String msg;
	//返回数据
	private Object data;
}
```

## 分层解耦

### 分层

三层架构：数据访问(Dao)、逻辑处理(Service)、接收请求响应数据(Controller)

* controller：控制层，，接收前端发送到请求，对请求进行处理，并响应数据。
* service：业务逻辑层，处理具体的业务逻辑
* dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括增删改查

### 解藕

* 内聚：软件中各个功能模块内部的功能联系
* 耦合：衡量软件中各个层/模块之间的依赖、关联的层度。
* 软件设计原则：高内聚低耦合

控制反转：IOC，对象的创建控制权由程序自身转移到外部（容器）

依赖注入：DI，容器为应用程序提供运行时，所依赖的资源

Bean对象：IOC容器中传教、管理的对象

## IOC&DI入门

控制反转

@Component  将当前类交给IOC容器，成为IOC容器中的bean

依赖注入

@Autowired  运行时，IOC容器会提供该类型的bean对象，并复制给该变量



## IOC详解

| @Componet   | 声明bean的基础注解                             |
| ----------- | ---------------------------------------------- |
| @Controller | 标注在控制器类上                               |
| @Service    | 标注在业务类上                                 |
| @Repository | 标注在数据访问类上（由于mybiatis整合，用到少） |

Bean默认名字为首字母小写的类名

如果需要改名字可以在注解后面加括号设置

@Repository("daoA")



@SpringBootApplication默认包含扫描器范围为当前包和子包

@ComponentScan为扫描

@ComponentScan({"dao","com.alan"})指定扫描那个包（不推荐）

## DI详解

因为默认是按类型进行的，如果存在多个相同类型的bean会报错

通常使用一下几种方案来解决

* @Primary 优先级
* @Qualifier 指定需要注入对应名字的bean
* @Resource 指定需要注入对应名字的bean，且不需要autowired注解了



## Mysql

关系型数据库（RDBMS）建立在关系模型基础上，由多张互相连接的二维表组成的数据库

### Sql

* 可以单行或多行书写，以分号结尾
* 可以使用空格/缩进来增强可读性
* 不区分大小写
* 注释
  * 单行：-- 
  * 多行/* */

分类

| 分类 | 说明                                                     |
| ---- | -------------------------------------------------------- |
| DDL  | 数据定义语言，定义数据库对象（数据库，表，字段）         |
| DMl  | 数据操作语言，对数据库表中的数据CUDA                     |
| DQL  | 数据查询语言，用来查询数据库表中的记录                   |
| DCL  | 数据库控制语言，用来创建数据库用户、控制数据库的访问权限 |

**需求+原型**

**设计**

概要设计、详细设计、接口设计、数据库设计

Java程序

优化->数据库优化

## DDL

**数据库 **

查询

​	查询所有数据库：show databases;

​	查询当前数据库: selsect database();

使用

​	使用数据库：use 数据库名；

创建

​	创建数据库：create database [if not exists] 数据库名;

删除

​	删除数据库: drop database [if exists] 数据库名;

**表**

[]可选

创建

```sql
create table 表名(
	字段1 字段类型 [约束] [comment 字段1注释],
  ......
  字段n 字段类型 [约束] [comment 字段n注释],
)[comment 表注释]
```

```sql
create table tb_user(
    id int primary key auto_increment comment 'ID,唯一标示',
    username varchar(20) not null unique comment '用户名',
    name varchar(10) not null comment '姓名',
    age int comment '年龄',
    gender char(1) default '男' comment '性别'
    ) comment '用户表';
```

**约束**

概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据

目的：保证数据库中数据的正确性，有效性，完整性

| 约束     | 描述                                                         | 关键字      |
| -------- | ------------------------------------------------------------ | ----------- |
| 非空约束 | 限制改字段值不能为null                                       | not null    |
| 唯一约束 | 保证字段的所有数据都是唯一，不重复的                         | unique      |
| 主键约束 | 主键是一行数据的唯一表示，要求非空且唯一，在后面添加auto_increment自动增加 | primary key |
| 默认约束 | 保存数据时，如果未指定该字段值，则采用默认值                 | default     |
| 外键约束 | 让两张表的数据建立连接，保证数据的一直性和完整性             | Foreign key |

数据类型：查表



## 表结构查询

* 查询当前数据库下所有表：show tables;

* 查询表结构: desc 表名;

* 查询建表语句: show create table 表名;

## 修改表结构

* 添加字段: alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];
* 修改字段类型: alter table 表名 modify 字段名 新数据类型(长度);
* 修改字段名和字段类型: alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]
* 删除字段: alter table 表名 drop column 字段名;
* 修改表名: rename table 表名 to 新表名;
* 删除表: drop table if exists 表名;

在删除表结构时，数据也会被删除



## DML

**插入数据**

* 指定字段添加数据: insert into 表名 (字段1,字段2) values (值1,值2);
* 全部字段添加数据: insert into 表名 values (值1,值2,...);
* 批量添加数据(指定字段): insert into 表名 (字段名1,字段名2) values (值1,值2),(值1,值2);
* 批量添加数据(全部字段):insert into 表名 values (值1，值2...),(值1，值2...);



更新时间可以使用now();

前面有多少个字段，有面就需要多少个值

字符串和日期需要用引号阔起来

插入的数据大小应该在字段限制之内

**更新数据**

* 修改数据: update 表名 set 字段名1=值1，字段名2=值2.... [where 条件];

没有where会更新整张表

**删除**

* 删除数据: delete from 表名 [where 条件];

没有条件会清空整张表的数据

不能删除某一个字段的值，如果要操作使用update设置为null

## DLQ

用来查询数据库中的记录Select

```sql
select
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表
order by
	排序字段列表
limit
	分页参数
```



**基本查询**

* 查询多个字段：select 字段1，字段2 from 表名;
* 查询所有字段: select * from 表名;
* 设置别名: select 字段1 [as 别名1] from 表名;
* 去除重复记录: select distinct 字段列表 from 表名;

**条件查询**

* 条件查询: select 字段列表 from 表名 where 条件列表;

| 比较运算符          | 功能                                     |
| ------------------- | ---------------------------------------- |
| >                   | 大于                                     |
| >=                  | 大于等于                                 |
| <                   | 小于                                     |
| <=                  | 小于等于                                 |
| =                   | 等于                                     |
| <>或!=              | 不等于                                   |
| between ... and ... | 在某个范围之内（含最小，最大值）         |
| in(...)             | 在in之后的列表中的值，多选一             |
| like 占位符         | 模糊匹配使用通配符'_'单个字符‘%’任意字符 |
| is null             | 是null                                   |

| 逻辑运算符 | 功能 |
| ---------- | ---- |
| and或&&    | 并且 |
| or或\|\|   | 或者 |
| not或\|    | 非   |

select * from tb_tmp where name='杨逍';

select * from tb_tmp where id <= 5;

select * from tb_tmp where job is null;

select * from tb_tmp where job is not null;

select * from tb_tmp where password != '123456';

select * from tb_tmp where entry data >= '2000-01-01' and data <='2010-01-01';

select * from tb_tmp where between '2000-01-01' and '2010-01-01';

select * from tb_tmp where between '2000-01-01' and '2010-01-01' and gender =2;

select * from tb_tmp where  job = 2 or job = 3 or job= 4;

select * from tb_tmp where job in (2,3,4) ;

select * from tb_tmp where name like '__';

select * from tb_tmp where name like '张%';

**分组查询**

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

语法：select 聚合函数(字段列表) from 表名;

统计企业员工数量

Select count(id) from tb_emp;//不对null记述

Select count(0) from tb_emp;//不对null记述

Select count(*) from tb_emp;//不对null记述

推荐count(*)

最早入职的员工

select min(entrydate) from tb_emp;

最迟入职员工

select max(entry date) from tb_emp;

统计某列的平均值

select avg(xx) from table;

求和

select sum(xx) from table;



**分组查询**

只能返回： 分组字段或聚合函数

语法:select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的条件];

根据性别分组，统计男生于女生的数量

select gender,count(*)  from tb_emp group by gender;

先查询入职之间在xxx-xxx 以前的员工，并结果根据职位分组，获取员工数量大于等于2的职位

select job, count(*) from tb_emp where entrydate <= 'xxx' group by job having count(*) >=2; 

**排序查询**

select 字段列表 from 表名 [where 条件] [group by 分组字段] order by 字段1 排序方式，字段2 排序方式...;

asc升序

desc降序

**分页查询**

select 字段列表 from 表名 limit 起始索引，查询记录条数;

从启始索引0开始查询员工数据，每页展示5条记录

select * from tb_emp limit 0,5;

从启始第1页开始查询员工数据，每页展示5条记录

select * from tb_emp limit 0,5;

从启始第2页开始查询员工数据，每页展示5条记录

select * from tb_emp limit 5,5;

从启始第3页开始查询员工数据，每页展示5条记录

select * from tb_emp limit 10,5;

启始索引（页码-1）*每页展示记录数

**案例**

按需求完成员工管理的条件分页查询，根据输入条件，查询第一页数据，每页展示10条记录

select * from tb_emp where name like '张%' and gender = 1 and entrydate between 'xxx' and 'xxx' order by update desc limit 0,10 ;

* if(条件，true取值，false取值)

select if(gender=1,'男性员工','女性员工')  性别 ,count(*) from tb_emp group by gender;

* case 表达式 when 值1 then结果1 when 值2 then 结果2 else ... end.

select (case job when 1 then '班主任' when 2 then '讲师' else ‘未分配职位' end) 职位,count(*) from tb_emp froup by job;

## 多表设计

**一对多**

多的一方关联一的一方

问题分析：两张表，在数据库层面并未建立关联，所以是无法保证数据的一致性和完整性的

**外键语法**

创建表时指定(所有字段罗列完后在最后添加)

```sql
create table 表名(
	字段名 数据类型
	...
	[constraint] [外键名称] foreign key (外键字段名) references 主表 (字段名称)
);
```

建完表后，添加外键

```sql
alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(字段名);
```

这种外键叫物理外键

概念：使用foreign key 定义外键关联另外一张表

缺点：

* 影响CRUD
* 仅用于单节点数据库，不适用分别是，集群场景
* 容易引发数据库的死锁问题，消耗性能



逻辑外键

概念：在业务层逻辑中，解决外键关联

通过逻辑外键，就可以很方便的解决上述问题

**一对一**

关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率

如果基本信息查询特别高，查询身份信息很低，可以拆分为两张表

实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）

**多对多*

实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键



## 多表查询

**内连接查询**

查询交集部分

表起别名在表后空格直接加名字

隐式内连接

```sql
select 字段列表 from 表1,表2 where 条件...;
```

显式内连接

```sql
select 字段列表 from 表1 [inner] join 表2 on 连接条件...;
```

**外连接**

左外连接(完全包含左表数据)

``` sql
select 字段列表 from 表1 left [outer] join 表2 on 连接条件...;
```

右外连接(完全包含右表数据)

``` sql
select 字段列表 from 表1 right [outer] join 表2 on 连接条件...;
```

**子查询**

SQL语句中嵌套select语句，成为嵌套查询，又称子查询

形式

``` sql
select * from t1 where column1=(select column1 from t2 ...);
```

子查询外部的语句可以式insert/update/delete/select

分类

* 标量子查询：子查询返回的结果为单个值

常用的操作符：= 、<>、 >、 >=、 <、 <=

``` sql
select * from tb_emp where dept_id = (select id from tb_dept where name = '教研部');
```

* 列子查询：子查询返回的结果为一列

常用操作符：in 、not in

``` sql
select * from tb_emp where dept_id in (select id from tb_dept where name = '教研部' or name = '咨询部');
```

* 行子查询返回的结果为一行

常用操作符：=、<>、in 、not in

``` sql
select * from tb_emp where (entrydate,job)=(select entrydate,job from tb_emp where name='韦一笑');
```

* 表子查询：子查询返回的结果为多行多列

常用操作符：in

``` sql
select e.*,d.name from (select * from tb_emp where entrydate > '2006-01-01') e, tb_dept d where e.dept_id = d.id;
```

## 事务

事务是一组操作的集合，它是一个不可分割的工作单位。事物会吧所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成果，要么同时失效

注意事项：默认mysql的事物是自动提交的，也就是说，当执行一条dml语句，mysql会立即隐式提交事务

事务控制

* 开启事务：start transaction;/begin;
* 提交事物: commit;
* 回滚事物: rollback;

先开启事务，然后执行多条sql如果成功就使用commit，如果失败则使用rollback

四大特性

* 原子性:最小单元，要么全部成功，要么全部失败

* 一致性：事物完成时，必须使所有数据都保持一致状态

* 隔离性：数据库系统提供的隔离机制，保证事物不受外部兵法操作影响的独立环境下运行

* 持久性：事物一旦提交或回滚，它对数据库中数据的改变就是永久的

## 索引

index时帮助数据库高效获取数据的数据结构

优点：

* 提高数据库查询的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗

缺点

* 索引会占用存储空间
* 索引大大提高了查询效率，同时也降低了insert、updata、delete的效率

B+tree（多路平衡搜索树)

**语法**

* 创建索引：

``` sql
create [unique] index 索引名 on 表名（字段名）;
```

* 查看索引

``` sql
show index from 表名;
```

* 删除索引

``` sql
drop index 索引名 on 表名;
```

## MyBatis

**快速入门**

使用Mybatis查询所有用户数据

1、准备工作（创建springboot工程、数据包user、实体类User）

2、引入Mybatis的相关依赖，配置Mybatis(数据库连接信息)

3、编写SQL语句（注解/XML）

**四要素**

``` 
#驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#数据库连接的url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
#连接数据库的用户名
spring.datasource.username=root
#连接数据库的密码
spring.datasource.password=1234
```

``` java
@Mapper
public interface UserMapper{
  @Select("select * from user")
  public List<User> list();
}
```

**JDBC**

jdbc就是使用java语言操作关系型数据库的一套API

是一套操作关系型数据库的规范，即接口

各个数据库厂商起实现这套接口，体空数据库的java包

我们可以使用这套接口编程，真正执行的代码是驱动jar包中的实现类

**数据库连接池**

数据库连接池是个容器，复制分配、管理数据库连接（Connection）

它运行应用程序重复使用一个现有的数据库连接，而不是再重新建立一个

释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接泄漏

标准接口

功能：获取链接：Connection getConnection() throws SQLException;

常见产品

C3P0、DBCP、DRuid（阿里巴巴开源）、Hikari（springboot默认）

切换链接池

* 引入依赖

```
<dependency>
   <groupId>com.alibaba</groupId>
   <artifactId>druid-spring-boot-starter</artifactId>
   <version>1.2.8</version>
</dependency>
```

* 配置链接信息

```
#驱动类名称
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#数据库连接的url
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
#连接数据库的用户名
spring.datasource.username=root
#连接数据库的密码
spring.datasource.password=1234
```

**lombok**

lombok是一个实用的java类库，能通过注解的形式自动生成构造器，getter/setter、equals、hashcode、toString等方法，并可以自动化生产日志变了，简化java开发，提高效率

| 注解                | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| @Getter/@Setter     | 为所有的属性提供get/set方法                                  |
| @ToString           | 会给类自动生成一阅读的toString方法                           |
| @EqualsAndHashCode  | 根据类所拥有的非静态字段自动重写equals方法和hashCOde方法     |
| @Data               | 提供了更综合的生成代码功能（@Getter+@Setter+@ToString+@EqualsAndHashCode） |
| @NoArgsConstructor  | 为实体类生成无参的构造器方法                                 |
| @AllArgsConstructor | 为实体类生成处理static修饰的字段之外代有各参数的构造器方法   |

```
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

lombok会在编译时，自动生成对于的java代码。我们使用lombok时，还需要安装一个lombok的插件（idea自带）

## 基础操作

**删除**

``` java
    @Delete("delete from emp where id = #{id}")
    public void delete(Integer id);
```

日志输入

可以在application.properties中，打开mybatis的日志，并输出到控制台

```
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

预编译sql的优势

性能更高

更安全（防止sql注入）

#{id}就会生成预编译sql

${id}会直接将参数拼接在后面，存在sql注入问题

**新增**

``` java
@Insert("insert into emp(username,name,gender,image,job,entrydate,dept_id,create_time,update_time"+
       " values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{dept_id},#{createTime},#{updateTime})")
public void insert(Emp emp);
```

**主键返回**

在数据添加成功后，需要获取插入数据库数据的主键

需要在添加的方法上添加注解

``` java
@Options(keyProperty = "id",useGeneratedKeys=true)
```

会将主键封装到id属性中，代表我们需要拿到主键值

**更新**

``` java
@Update("update emp set username=#{username},name=#{name},gender=#{gender},image=#{image},job=#{job},entrydate=#{entrydate},dept_id=#{deptid},update_time=#{updateTime where id=#{id}}")
public void update(Emp emp);
```

**查询**

``` java
@Select("select * from emp where id=#{id}")
public Emp getById(Integer id);
```

数据封装

实体类书姓名和数据库表查询返回到字段名一致，mybatis会自动封装

如果实体类书姓名和数据库表查询返回的字段名不一致，不能自动封装

* 方案一：给字段起别名，让别名于实体类属性一致

``` java
@Select("select xxx aaa,xxxx aaaa from emp where id=#{id}")
public Emp getById(Integer id);
```

* 方案二，通过@Results,@Result注解手动映射封装

``` java
@Results({
  @Result(column = "dept_id",property = "deptId"),
  @Result(column = "create_time",property = "createTime"),
  @Result(column = "update_time",property = "updateTime"),
})
@Select("select * from emp where id=#{id}")
public Emp getById(Integer id);
```

* 方案三：开启mybatis的驼峰命名自动映射开关 a_column --->aColumn

``` properties
mybatis.configuration.map-underscore-to-camel-case=true
```

