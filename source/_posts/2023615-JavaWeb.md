---
Title: JavaWeb
Date: 2023/6/15 16:10
Tags: [笔记]

---



## 简单请求参数

http://localhost:8080/xxx?name=1&age=2

```java
    @RequestMapping("/simpleParam")
    public String simpleParam(HttpServletRequest request){
        String name = request.getParameter("name");
        String age = request.getParameter("age");
        return name+age;
    }
```

```java
    @RequestMapping("/simpleParam")
    public String simpleParam(String name, Integer age){

        return name+age;
    }
```

如果参数名不匹配，则使用@RequestParam建立映射

```java
    @RequestMapping("/simpleParam")
    public String simpleParam(@RequestParam(name="name",required = false)String username, Integer age){

        return username+age;
    }
```

将参数封装到实体类

```java
    @RequestMapping("/simplePojo")
    public String simplePojo(User user){

        return user.getName() +user.getAge();
    }
```

## 接收数组参数

http://localhost:8080/xxx?hobby=1&hobby=2&hobby=3

```java
    @RequestMapping("/arrayParam")
    public String arrayParam(String[] hobby){

        System.out.println(Arrays.toString(hobby));
        return "ok";
    }
```

```java
    @RequestMapping("/arrayParam2")
    public String arrayParam2(@RequestParam List<String> hobby){

        System.out.println(hobby);
        return "ok";
    }
```

## 日期参数

http://localhost:8080/xxx?updateTime-2022-12-12 10:05:45

```java
    @RequestMapping("/arrayParam3")
    public String arrayParam3(@DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")LocalDateTime updateTime){
        System.out.println(updateTime);

        return "ok";
    }
```

## Json参数

json数据键名与形参属姓名相同，定义pojo类型即可接收参数，需要使用@RequesBody标示

```json
{
    "name":"Tom",
    "age":10,
    "address":{
        "name":"shanghai"
    }

}
```

```java
    @RequestMapping("/arrayParam4")
    public String arrayParam4(@RequestBody User user){
        System.out.println(user);

        return "ok";
    }
```

## 路径参数

通过请求URL直接换地参数用{}来识别路径参数，需要使用@PathVariable来获取路径参数

http://localhost:8080/arrayParam5/1

```
    @RequestMapping("/arrayParam5/{id}")
    public String arrayParam5(@PathVariable Integer id){
        System.out.println(id);

        return "ok";
    }
```

http://localhost:8080/arrayParam5/1/2

    @RequestMapping("/arrayParam5/{id}/{name}")
    public String arrayParam5(@PathVariable Integer id,@PathVariable Integer name){
        System.out.println(id+name);
    
        return "ok";
    }

## 相应数据

都来源于注解@ResponseBody只不过@RestController中已经包含

返回字符串就直接但会

实体类对象会转json

数组依然是数组  

统一都响应结果

```
public class Result{
	//相应码，1代表成果，0代表失败
	private Integetr code;
	//提示信息
	private String msg;
	//返回数据
	private Object data;
}
```

## 分层解耦

### 分层

三层架构：数据访问(Dao)、逻辑处理(Service)、接收请求响应数据(Controller)

* controller：控制层，，接收前端发送到请求，对请求进行处理，并响应数据。
* service：业务逻辑层，处理具体的业务逻辑
* dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括增删改查

### 解藕

* 内聚：软件中各个功能模块内部的功能联系
* 耦合：衡量软件中各个层/模块之间的依赖、关联的层度。
* 软件设计原则：高内聚低耦合

控制反转：IOC，对象的创建控制权由程序自身转移到外部（容器）

依赖注入：DI，容器为应用程序提供运行时，所依赖的资源

Bean对象：IOC容器中传教、管理的对象

## IOC&DI入门

控制反转

@Component  将当前类交给IOC容器，成为IOC容器中的bean

依赖注入

@Autowired  运行时，IOC容器会提供该类型的bean对象，并复制给该变量



## IOC详解

| @Componet   | 声明bean的基础注解                             |
| ----------- | ---------------------------------------------- |
| @Controller | 标注在控制器类上                               |
| @Service    | 标注在业务类上                                 |
| @Repository | 标注在数据访问类上（由于mybiatis整合，用到少） |

Bean默认名字为首字母小写的类名

如果需要改名字可以在注解后面加括号设置

@Repository("daoA")



@SpringBootApplication默认包含扫描器范围为当前包和子包

@ComponentScan为扫描

@ComponentScan({"dao","com.alan"})指定扫描那个包（不推荐）

## DI详解

因为默认是按类型进行的，如果存在多个相同类型的bean会报错

通常使用一下几种方案来解决

* @Primary 优先级
* @Qualifier 指定需要注入对应名字的bean
* @Resource 指定需要注入对应名字的bean，且不需要autowired注解了



## Mysql

关系型数据库（RDBMS）建立在关系模型基础上，由多张互相连接的二维表组成的数据库

### Sql

* 可以单行或多行书写，以分号结尾
* 可以使用空格/缩进来增强可读性
* 不区分大小写
* 注释
  * 单行：-- 
  * 多行/* */

分类

| 分类 | 说明                                                     |
| ---- | -------------------------------------------------------- |
| DDL  | 数据定义语言，定义数据库对象（数据库，表，字段）         |
| DMl  | 数据操作语言，对数据库表中的数据CUDA                     |
| DQL  | 数据查询语言，用来查询数据库表中的记录                   |
| DCL  | 数据库控制语言，用来创建数据库用户、控制数据库的访问权限 |

**需求+原型**

**设计**

概要设计、详细设计、接口设计、数据库设计

Java程序

优化->数据库优化

## DDL

**数据库 **

查询

​	查询所有数据库：show databases;

​	查询当前数据库: selsect database();

使用

​	使用数据库：use 数据库名；

创建

​	创建数据库：create database [if not exists] 数据库名;

删除

​	删除数据库: drop database [if exists] 数据库名;

**表**

[]可选

创建

```sql
create table 表名(
	字段1 字段类型 [约束] [comment 字段1注释],
  ......
  字段n 字段类型 [约束] [comment 字段n注释],
)[comment 表注释]
```

```sql
create table tb_user(
    id int primary key auto_increment comment 'ID,唯一标示',
    username varchar(20) not null unique comment '用户名',
    name varchar(10) not null comment '姓名',
    age int comment '年龄',
    gender char(1) default '男' comment '性别'
    ) comment '用户表';
```

**约束**

概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据

目的：保证数据库中数据的正确性，有效性，完整性

| 约束     | 描述                                                         | 关键字      |
| -------- | ------------------------------------------------------------ | ----------- |
| 非空约束 | 限制改字段值不能为null                                       | not null    |
| 唯一约束 | 保证字段的所有数据都是唯一，不重复的                         | unique      |
| 主键约束 | 主键是一行数据的唯一表示，要求非空且唯一，在后面添加auto_increment自动增加 | primary key |
| 默认约束 | 保存数据时，如果未指定该字段值，则采用默认值                 | default     |
| 外键约束 | 让两张表的数据建立连接，保证数据的一直性和完整性             | Foreign key |

数据类型：查表



## 表结构查询

* 查询当前数据库下所有表：show tables;

* 查询表结构: desc 表名;

* 查询建表语句: show create table 表名;

## 修改表结构

* 添加字段: alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];
* 修改字段类型: alter table 表名 modify 字段名 新数据类型(长度);
* 修改字段名和字段类型: alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]
* 删除字段: alter table 表名 drop column 字段名;
* 修改表名: rename table 表名 to 新表名;
* 删除表: drop table if exists 表名;

在删除表结构时，数据也会被删除



## DML

**插入数据**

* 指定字段添加数据: insert into 表名 (字段1,字段2) values (值1,值2);
* 全部字段添加数据: insert into 表名 values (值1,值2,...);
* 批量添加数据(指定字段): insert into 表名 (字段名1,字段名2) values (值1,值2),(值1,值2);
* 批量添加数据(全部字段):insert into 表名 values (值1，值2...),(值1，值2...);



更新时间可以使用now();

前面有多少个字段，有面就需要多少个值

字符串和日期需要用引号阔起来

插入的数据大小应该在字段限制之内

**更新数据**

* 修改数据: update 表名 set 字段名1=值1，字段名2=值2.... [where 条件];

没有where会更新整张表

**删除**

* 删除数据: delete from 表名 [where 条件];

没有条件会清空整张表的数据

不能删除某一个字段的值，如果要操作使用update设置为null

## DLQ

用来查询数据库中的记录Select

```sql
select
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表
order by
	排序字段列表
limit
	分页参数
```



**基本查询**

* 查询多个字段：select 字段1，字段2 from 表名;
* 查询所有字段: select * from 表名;
* 设置别名: select 字段1 [as 别名1] from 表名;
* 去除重复记录: select distinct 字段列表 from 表名;

**条件查询**

* 条件查询: select 字段列表 from 表名 where 条件列表;

| 比较运算符          | 功能                                     |
| ------------------- | ---------------------------------------- |
| >                   | 大于                                     |
| >=                  | 大于等于                                 |
| <                   | 小于                                     |
| <=                  | 小于等于                                 |
| =                   | 等于                                     |
| <>或!=              | 不等于                                   |
| between ... and ... | 在某个范围之内（含最小，最大值）         |
| in(...)             | 在in之后的列表中的值，多选一             |
| like 占位符         | 模糊匹配使用通配符'_'单个字符‘%’任意字符 |
| is null             | 是null                                   |

| 逻辑运算符 | 功能 |
| ---------- | ---- |
| and或&&    | 并且 |
| or或\|\|   | 或者 |
| not或\|    | 非   |

select * from tb_tmp where name='杨逍';

select * from tb_tmp where id <= 5;

select * from tb_tmp where job is null;

select * from tb_tmp where job is not null;

select * from tb_tmp where password != '123456';

select * from tb_tmp where entry data >= '2000-01-01' and data <='2010-01-01';

select * from tb_tmp where between '2000-01-01' and '2010-01-01';

select * from tb_tmp where between '2000-01-01' and '2010-01-01' and gender =2;

select * from tb_tmp where  job = 2 or job = 3 or job= 4;

select * from tb_tmp where job in (2,3,4) ;

select * from tb_tmp where name like '__';

select * from tb_tmp where name like '张%';

**分组查询**

| 函数  | 功能     |
| ----- | -------- |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

语法：select 聚合函数(字段列表) from 表名;

统计企业员工数量

Select count(id) from tb_emp;//不对null记述

Select count(0) from tb_emp;//不对null记述

Select count(*) from tb_emp;//不对null记述

推荐count(*)

最早入职的员工

select min(entrydate) from tb_emp;

最迟入职员工

select max(entry date) from tb_emp;

统计某列的平均值

select avg(xx) from table;

求和

select sum(xx) from table;



**分组查询**

只能返回： 分组字段或聚合函数

语法:select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的条件];

根据性别分组，统计男生于女生的数量

select gender,count(*)  from tb_emp group by gender;

先查询入职之间在xxx-xxx 以前的员工，并结果根据职位分组，获取员工数量大于等于2的职位

select job, count(*) from tb_emp where entrydate <= 'xxx' group by job having count(*) >=2; 

**排序查询**

select 字段列表 from 表名 [where 条件] [group by 分组字段] order by 字段1 排序方式，字段2 排序方式...;

asc升序

desc降序

**分页查询**

select 字段列表 from 表名 limit 起始索引，查询记录条数;

从启始索引0开始查询员工数据，每页展示5条记录

select * from tb_emp limit 0,5;

从启始第1页开始查询员工数据，每页展示5条记录

select * from tb_emp limit 0,5;

从启始第2页开始查询员工数据，每页展示5条记录

select * from tb_emp limit 5,5;

从启始第3页开始查询员工数据，每页展示5条记录

select * from tb_emp limit 10,5;

启始索引（页码-1）*每页展示记录数

**案例**

按需求完成员工管理的条件分页查询，根据输入条件，查询第一页数据，每页展示10条记录

select * from tb_emp where name like '张%' and gender = 1 and entrydate between 'xxx' and 'xxx' order by update desc limit 0,10 ;

* if(条件，true取值，false取值)

select if(gender=1,'男性员工','女性员工')  性别 ,count(*) from tb_emp group by gender;

* case 表达式 when 值1 then结果1 when 值2 then 结果2 else ... end.

select (case job when 1 then '班主任' when 2 then '讲师' else ‘未分配职位' end) 职位,count(*) from tb_emp froup by job;

## 多表设计
